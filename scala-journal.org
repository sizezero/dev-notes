
* 2014-11-26

Minor success.  Added a junit test to the android-sbt-plugin
autogenerated project and was able to run it via "sbt android:test"

Tracking changes in gen-android branch custom1

* 2014-11-24

The scaloid sample app seems to have a strange directory structure

#+BEGIN_SRC bash
src/scaloid/example/HelloScaloid.scala
#+END_SRC

Android usually puts tests in a separate project.  I wonder if that's
how this works?

Added android-sdk-plugin to global plugins:

#+BEGIN_SRC bash
~/.sbt/0.13/plugins/build.sbt
addSbtPlugin("com.hanhuy.sbt" % "android-sdk-plugin" % "1.3.10")
#+END_SRC

This allows generation of new android projects via:

#+BEGIN_SRC bash
mkdir test1
cd test1
sbt "gen-android android-19 org.kleemann.test1 test1"
#+END_SRC

Strange that it produces all java files.  What's the point?

Having lots of problems getting tests to run.  The above
android-sdk-plugin call generates the following directory structure.

#+BEGIN_SRC bash
src/
src/androidTest
src/androidTest/java
src/androidTest/java/org
src/androidTest/java/org/kleemann
src/androidTest/java/org/kleemann/MainActivityTest.java
src/main
src/main/AndroidManifest.xml
src/main/java
src/main/java/org
src/main/java/org/kleemann
src/main/java/org/kleemann/MainActivity.java
src/main/res
src/main/res/drawable-xhdpi
src/main/res/drawable-xhdpi/ic_launcher.png
src/main/res/drawable-mdpi
src/main/res/drawable-mdpi/ic_launcher.png
src/main/res/drawable-ldpi
src/main/res/drawable-ldpi/ic_launcher.png
src/main/res/drawable-hdpi
src/main/res/drawable-hdpi/ic_launcher.png
src/main/res/layout
src/main/res/layout/main.xml
src/main/res/values
src/main/res/values/strings.xml
#+END_SRC

There seems to be two possible ways to configure the sbt build:

#+BEGIN_SRC bash
build.sbt
project/
  build.scala
  build.properties
project/
  plugins.sbt
  build.properties
#+END_SRC


* 2014-11-23

Failure to find zipalign requires a new version of android-sdk-plugin
Change via project/plugins.sbt from 1.3.6 to 1.3.10

"The SDK Build Tools revision (19.0.3) is too low for project
'hello-scaloid-sbt'. Minimum required is 19.1.0" Updated via "android
sdk" Finally compiled. "android avd&" and "sbt run" runs the app.

"sbt ~run" allows dynamic rebuilds and redeployment.  Editing files
via emacs.  Maybe I should try to do this with sbt, emacs, and the
command line tools for a while.  Will give me some nuts and bolts
experience without an IDE.  Starting with the old, moldy scala mode
that comes with Ubuntu: scala-dist/tool-support/src/emacs The newer
version hvesalai/scala-mode2 would have to be installed manually.

* 2014-11-22

I'm going to be trying some Android development in scala.  This is
going to require:

- The android SDK (not necessarily the whole ADT custom eclipse) just
  ANDROID_HOME pointing to the sdk directory
- the android-sbt-plugin for sbt seems to be needed to make easy sbt
  builds.  This handles the complicated stuff such as resource
  building and proguard post-processing to cut the jar down to a
  managable size.
- scaloid is a library that adds scala like wrappers around common
  android calls.  This seems necessary.
- For eclipse it seems the best thing to do is install the scala ide
  and then add the android plugins to it.  Some icons seem missing as
  apposed to the eclipse android bundle.

Unfortunately all of this isn't a happy place.

- The android-sbt and scaloid folks want the primary build to be an
  sbt project and then have your IDE plug into that.  They seem to
  like IDEA and hate Eclipse so the Eclipse support sucks.
- The Scala IDE (Eclipse) folks don't seem to care much about Android
  and even suggest starting an Eclipse android java project and adding
  scala to it after the fact.  This would prevent external builds.
- Google seems to be transitioning from Eclipse as the official
  Android IDE to IDEA.

I'm not sure where to go with all of this.  I am used to Eclipse and
have nothing against IDEA but I'd rather not have to start paying for
an editor.

Scala IDE 3.0.4; Scala 2.10

Hello scaloid github project currently needs sbt 0.13.5 or above,
needs Android SDK level 10

Installing sbt v0.13.7 to give it a shot instead of activator

* 2014-11-08

Ran into a case where I was writing a pure function that reformats a
string for pretty printing.  The natural solution that came to me was
imperative but I thought I would implement it a functional way just to
compare them. I like the imperative solution better.

#+BEGIN_SRC scala
  /**
   * Add some newlines and indentation to make the objects easier to read
   */
  def prettyPrint: String = {
    // it would be interesting to see this functionally instead of imperatively
    // I would imagine lots of objects would be generated in order to handle indents
    var indent = 0
    val sb = new StringBuilder() 
    for (c <- toString) {
      c match {
        case '(' => {
          sb.append("(\n")
          indent += 2
          sb.append(" " * indent)
        }
        case ')' => {
          sb.append(")\n")
          indent -= 2
          sb.append(" " * indent)
        }
        case ',' => {
          sb.append(",\n")
          sb.append(" " * indent)
        }
        case _ => sb.append(c)
      }
    }
    sb.toString
  }
#+END_SRC

#+BEGIN_SRC scala
  // this is shorter but way more obscure than the imperative approach
  def prettyPrintFunctional: String = {
    toString.foldLeft((0, "")){ (t, c) =>
      t match {
        case (i, s) => c match {
          case '(' => (i+2, s + "(\n" + " " * (i+2))
          case ')' => (i-2, s + ")\n" + " " * (i-2))
          case ',' => (i, s + ")\n" + " " * i)
          case _ => (i, s + c)
        }
      }
    }._2
  }
#+END_SRC

I think functional solutions run into problems when you have to pass a
large amount of state between iterations.

* 2014-11-04

Trying to do a couple things:

- use case classes with matching instead of heavyweight OOP classes
- favor functional style and immutablilty

This is probably not the best choice in all cases but it gives me a
little more experience with these other programming paradigms

* 2014-11-03

For some reason I can run the eclipsify command from the command line
now:

#+BEGIN_SRC bash
$ activator eclipse
#+END_SRC

...I swear this wasn't working yesterday.  I think with a fresh
install of the activator, you may have to run the "make eclipse files"
once with the ui before you are able to run it from the command line.

* 2014-11-02

Not sure if all the files should be added to the project.  Adding the
activator jar seems strange.  Stackoverflow says their only purpose is
for allowing builds for people that don't have activator installed.
Seems kind of dumb.  My policy will be to delete them.

http://stackoverflow.com/questions/26131829/what-are-activator-and-activator-launch-1-2-10-jar-files-in-a-new-project-with-p

Maybe I should keep that new project snippet in a separate place.  If
I use it a lot, it may make sense to make my own template or bash
script.

TODO: learn more about scala-ide, formatting, etc.

Selecting a source file or package from the package explorer allows
the "source" menu to appear which allows the "format" command.  This
is a good way to clean up poorly formatted scala.  Seems to also get
rid of hard tabs.

TODO: check for tabs in source code

It seems scala formatting inherits from java.  Need to make a custom
java formatter that doesn't use tabs.

https://www.assembla.com/spaces/scala-ide/tickets/1000198#/activity/ticket:

TODO: see if Scalastyle is used by the ide

TODO: the parsing shown in scells is more interesting than I had
thought.  Read the chapter on combinator parsing.

TODO: configure eclipse to trim trailing spaces

* 2014-11-01

I probably should have been doing this a while ago.  Now is better
than nothing.

While reading functional programming with scala I was working with a
lot of functions that were returning functions. It turns out that that
syntax produces an identical signature as the curry syntax. e.g.

#+BEGIN_SRC scala
object curry {
  
  def f1(a: Int): Int => Int =
  	b => a + b                                //> f1: (a: Int)Int => Int
  	
  def f2(a: Int)(b: Int): Int =
  	a + b                                     //> f2: (a: Int)(b: Int)Int

	// note: both functions can be assigned to x and y which means they have the same type
  var x = f1(42)                                  //> x  : Int => Int = <function1>
  x(3)                                            //> res0: Int = 45
  x = f2(42)
  x(3)                                            //> res1: Int = 45
  
  var y = f2 _                                    //> y  : Int => (Int => Int) = <function1>
  y(42)(3)                                        //> res2: Int = 45
  y = f1 _
  y(42)(3)                                        //> res3: Int = 45
  
}
#+END_SRC

Try to learn the basics of sbt, activator, eclipse.  Some minimal ways
to get started:

Had to add sbteclipse to plugins dir

#+BEGIN_SRC bash
cd ~/.sbt
mkdir plugins
echo 'addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "2.1.2")' >> ~/.sbt/plugins/plugins.sbt
#+END_SRC

The above command did not seem to allow eclipse to be run from
activator.  I was only able to create the eclipse project files with
"activator ui"

#+BEGIN_SRC bash
activator new myproject minimal-scala
cd myproject
rm activator*
git init
git status
<add .cache .classpath .project to .gitignore>
git add <files listed in status>
git commit -a -m "initial changes to template"
<add project via github website>
git remote add origin https://github.com/sizezero/PROJECTNAME.git
git push origin master
activator compile
activator eclipse
#+END_SRC

